#include <protomol/integrator/leapfrog/BufferGas.h>
#include <protomol/base/PMConstants.h>
#include <cmath>

using namespace ProtoMol;

BufferGas::BufferGas() :
  _m(0),
  _temp(0),
  _freq(0),
  _vn(0),
  _T(NULL),
  _r(NULL)
{
}

BufferGas::~BufferGas() {
  if (_r)
    gsl_rng_free(_r);
}

        
BufferGas::BufferGas (LuaState::LuaState& L) {
  gsl_rng_env_setup();  
  _T = gsl_rng_default;
  _r = gsl_rng_alloc(_T);
  
  _mass = L.get<double>("neutral.mass") * ProtoMol::Constant::SI::AMU;
  _freq = L.get<double>("neutral.collision_frequency");
  _temperature = L.get<double>("neutral.temperature");
  _vn = sqrt(ProtoMol::Constant::SI::BOLTZMANN * _temperature / _mass); 
}

void BufferGas::collide(double m, Vector3D& p, Vector3D& v) {
  Vector3D v_n, v_com, v_rel, v_rel_after;

  double mag = gsl_ran_chisq(r, 3);
  mag = sqrt(mag) * _vn;

  gsl_ran_dir_3d(r, &v_n[0], &v_n[1], &v_n[2]);
  v_n *= mag;
  
  double b1 = m / (_mass+m);
  double b2 = 1-b1;

  v_com = v * b1 + v_n * b2;
  v_rel = v - v_n;
  
  double norm = v_rel.norm();
  gsl_ran_dir_3d(r, &v_rel_after[0], &v_rel_after[1], &v_rel_after[2]);
  v_rel_after *= norm;
  
  v = v_com + v_rel_after * b2;
}

bool compareFunction(const CollisionEvent p1, const CollisionEvent p2) {
  return p1.time < p2.time;
}

vector<CollisionEvent> BufferGas::createCollisionSchedule(double start, double end, int atomCount) {
  vector<CollisionEvent> s;

  for (int n=0; n<atomCount; n++) 
    for (double t = start; t<end; t += gsl_ran_exponential(r, 1.0/freq))
	s.push_back(CollisionEvent(n, t));

  sort(s.begin(), s.end(), compareFunction);
  
  return s;
}
