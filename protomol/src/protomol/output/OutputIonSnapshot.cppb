#include "OutputIonSnapshot.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <sstream>
#include <protomol/ProtoMolApp.h>
#include <protomol/module/MainModule.h>
#include <protomol/base/StringUtilities.h>
#include <protomol/base/PMConstants.h>
#include <protomol/io/LuaConfigReader.h>

extern int errno;
using namespace ProtoMol;

using namespace std;
using namespace Util;

const string OutputIonSnapshot::keyword("IonSnapshot");

OutputIonSnapshot::OutputIonSnapshot(): Output(-1)
{}

OutputIonSnapshot::~OutputIonSnapshot() {
  for (int i=0; i<fileId.size(); i++)
    H5Fclose(fileId[i]);
}

OutputIonSnapshot::OutputIonSnapshot(const std::string& filename):
  Output(1),
  atomCount(0),
  nextSnapshot(0),
  outputDir(""),
  L(filename)
{
  trap = Lqt(L);
  timeMin = L.get<double>("time.min");
  timeMax = L.get<double>("time.max");
  timeStep = L.get<double>("time.step");

  outputDir = L.get<string>("dir");

  int status = mkdir(outputDir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
  if (status)
    if (errno != EEXIST)
      throw (status);

}

int OutputIonSnapshot::GenerateSnapshot() {
  double conversion = 1e-10 * ProtoMol::Constant::SI::TIME_FS / ProtoMol::Constant::TIMEFACTOR;

  hid_t dataspace_id, dataset_id;
  herr_t status;
  hsize_t dims[2] = { atomCount, 14 };

  double *data = new double[atomCount * 14];

  vector<double> totEnergy, secEnergy;

  for (int i=0; i<atomCount; i++) {
    trap.GetEnergy(app->positions[i]*1e-10, app->velocities[i]*conversion , timeMark[nextSnapshot]*h, totEnergy, secEnergy);

    for (int j=0; j<3; j++) {
      // Positions
      data[i*14+j] = app->positions[i][j] * 1e-10;

      // Velocities
      data[i*14+j+3] = app->velocities[i][j] * conversion;
      
      // Total Energy and Secular Energy
      data[i*14+j+6] = totEnergy[j];
      data[i*14+j+9] = secEnergy[j];
      
      // Average Total
      data[i*14+12] = (data[i*14+6] + data[i*14+7]  + data[i*14+8])/3;
      data[i*14+13] = (data[i*14+9] + data[i*14+10] + data[i*14+11])/3;
    }
  }
  dataspace_id = H5Screate_simple(2, dims, NULL);
  dataset_id = H5Dcreate(fileId[nextSnapshot], "/dset", H5T_NATIVE_DOUBLE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  
  status = H5Dwrite(dataset_id, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);
  status = H5Dclose(dataset_id);
  status = H5Sclose(dataspace_id);

  // for(int i = 0; i < atomCount; ++i) 
  //   delete [] data[i];

  delete [] data;
  return status;
}


Output* OutputIonSnapshot::doMake(const std::vector<Value> &values) const
{
  return new OutputIonSnapshot(values[0]);
}

void OutputIonSnapshot::getParameters(std::vector<Parameter> &parameter) const
{
  parameter.push_back(Parameter(getId(), Value(filename, ConstraintValueType::NotEmpty())));
}

     
void OutputIonSnapshot::doInitialize()
{
  atomCount = app->topology->atoms.size();
  h = getOutputFreq() * app->integrator->getTimestep() / Constant::SI::TIME_FS;

  ostringstream ss;
  ss.unsetf(ios::floatfield);
  ss.precision(5);
  
  double t;
  
  for (t=timeMin; t<timeMax; t+=timeStep) {
    timeMark.push_back(static_cast<int>(t/h));
    ss << scientific << outputDir << "/time_" << t << ".hd5";
    fileId.push_back(H5Fcreate(ss.str().c_str(), H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
    ss.flush();
    ss.str("");
  }
  
}

void OutputIonSnapshot::doRun(int step)
{
  int currentTimeMark = static_cast<int>(app->topology->time/Constant::SI::TIME_FS / h);
  if (currentTimeMark > timeMark[nextSnapshot] && nextSnapshot!=timeMark.size()) {
    GenerateSnapshot();
    nextSnapshot++;
  }
}

void OutputIonSnapshot::doFinalize(int step) {
}

